// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package repo

import (
	"context"
	"database/sql"
	"time"
)

const createRecurring = `-- name: CreateRecurring :one
INSERT INTO recurring (user_id, amount_pence, description, frequency, interval_n, first_due_date, next_due_date, end_date, active)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, user_id, amount_pence, description, frequency, interval_n, first_due_date, next_due_date, end_date, active, created_at
`

type CreateRecurringParams struct {
	UserID       int64
	AmountPence  int64
	Description  sql.NullString
	Frequency    string
	IntervalN    int64
	FirstDueDate time.Time
	NextDueDate  time.Time
	EndDate      sql.NullTime
	Active       bool
}

func (q *Queries) CreateRecurring(ctx context.Context, arg CreateRecurringParams) (Recurring, error) {
	row := q.db.QueryRowContext(ctx, createRecurring,
		arg.UserID,
		arg.AmountPence,
		arg.Description,
		arg.Frequency,
		arg.IntervalN,
		arg.FirstDueDate,
		arg.NextDueDate,
		arg.EndDate,
		arg.Active,
	)
	var i Recurring
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AmountPence,
		&i.Description,
		&i.Frequency,
		&i.IntervalN,
		&i.FirstDueDate,
		&i.NextDueDate,
		&i.EndDate,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const createRecurringTag = `-- name: CreateRecurringTag :exec
INSERT INTO recurring_tags (recurring_id, tag_id)
VALUES (?, ?)
ON CONFLICT(recurring_id, tag_id) DO NOTHING
`

type CreateRecurringTagParams struct {
	RecurringID int64
	TagID       int64
}

func (q *Queries) CreateRecurringTag(ctx context.Context, arg CreateRecurringTagParams) error {
	_, err := q.db.ExecContext(ctx, createRecurringTag, arg.RecurringID, arg.TagID)
	return err
}

const createSetting = `-- name: CreateSetting :one
INSERT INTO settings (key, value)
VALUES (?, ?)
ON CONFLICT(key) DO UPDATE SET value = excluded.value
RETURNING "key", value
`

type CreateSettingParams struct {
	Key   string
	Value string
}

func (q *Queries) CreateSetting(ctx context.Context, arg CreateSettingParams) (Setting, error) {
	row := q.db.QueryRowContext(ctx, createSetting, arg.Key, arg.Value)
	var i Setting
	err := row.Scan(&i.Key, &i.Value)
	return i, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tags (name)
VALUES (?)
RETURNING id, name
`

func (q *Queries) CreateTag(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, createTag, name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (user_id, amount_pence, t_date, note, source_recurring)
VALUES (?, ?, ?, ?, ?)
RETURNING id, user_id, amount_pence, t_date, note, created_at, source_recurring, deleted_at
`

type CreateTransactionParams struct {
	UserID          int64
	AmountPence     int64
	TDate           time.Time
	Note            sql.NullString
	SourceRecurring sql.NullInt64
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.UserID,
		arg.AmountPence,
		arg.TDate,
		arg.Note,
		arg.SourceRecurring,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AmountPence,
		&i.TDate,
		&i.Note,
		&i.CreatedAt,
		&i.SourceRecurring,
		&i.DeletedAt,
	)
	return i, err
}

const createTransactionTag = `-- name: CreateTransactionTag :exec
INSERT INTO transaction_tags (transaction_id, tag_id)
VALUES (?, ?)
ON CONFLICT(transaction_id, tag_id) DO NOTHING
`

type CreateTransactionTagParams struct {
	TransactionID int64
	TagID         int64
}

func (q *Queries) CreateTransactionTag(ctx context.Context, arg CreateTransactionTagParams) error {
	_, err := q.db.ExecContext(ctx, createTransactionTag, arg.TransactionID, arg.TagID)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, pw_hash)
VALUES (?, ?)
RETURNING id, email, pw_hash, created_at
`

type CreateUserParams struct {
	Email  string
	PwHash string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Email, arg.PwHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PwHash,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAllRecurringTags = `-- name: DeleteAllRecurringTags :exec
DELETE FROM recurring_tags
WHERE recurring_id = ?
`

func (q *Queries) DeleteAllRecurringTags(ctx context.Context, recurringID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAllRecurringTags, recurringID)
	return err
}

const deleteAllTransactionTags = `-- name: DeleteAllTransactionTags :exec
DELETE FROM transaction_tags
WHERE transaction_id = ?
`

func (q *Queries) DeleteAllTransactionTags(ctx context.Context, transactionID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAllTransactionTags, transactionID)
	return err
}

const deleteRecurring = `-- name: DeleteRecurring :exec
DELETE FROM recurring
WHERE id = ?
`

func (q *Queries) DeleteRecurring(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRecurring, id)
	return err
}

const deleteRecurringTag = `-- name: DeleteRecurringTag :exec
DELETE FROM recurring_tags
WHERE recurring_id = ? AND tag_id = ?
`

type DeleteRecurringTagParams struct {
	RecurringID int64
	TagID       int64
}

func (q *Queries) DeleteRecurringTag(ctx context.Context, arg DeleteRecurringTagParams) error {
	_, err := q.db.ExecContext(ctx, deleteRecurringTag, arg.RecurringID, arg.TagID)
	return err
}

const deleteSetting = `-- name: DeleteSetting :exec
DELETE FROM settings
WHERE key = ?
`

func (q *Queries) DeleteSetting(ctx context.Context, key string) error {
	_, err := q.db.ExecContext(ctx, deleteSetting, key)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags
WHERE id = ?
`

func (q *Queries) DeleteTag(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTag, id)
	return err
}

const deleteTransactionTag = `-- name: DeleteTransactionTag :exec
DELETE FROM transaction_tags
WHERE transaction_id = ? AND tag_id = ?
`

type DeleteTransactionTagParams struct {
	TransactionID int64
	TagID         int64
}

func (q *Queries) DeleteTransactionTag(ctx context.Context, arg DeleteTransactionTagParams) error {
	_, err := q.db.ExecContext(ctx, deleteTransactionTag, arg.TransactionID, arg.TagID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getMonthlyReport = `-- name: GetMonthlyReport :many
SELECT 
    t.name as tag_name,
    SUM(CASE WHEN tx.amount_pence > 0 THEN tx.amount_pence ELSE 0 END) as total_in_pence,
    SUM(CASE WHEN tx.amount_pence < 0 THEN ABS(tx.amount_pence) ELSE 0 END) as total_out_pence,
    COUNT(*) as transaction_count
FROM transactions tx
LEFT JOIN transaction_tags tt ON tx.id = tt.transaction_id
LEFT JOIN tags t ON tt.tag_id = t.id
WHERE tx.user_id = ? 
  AND tx.deleted_at IS NULL
  AND strftime('%Y-%m', tx.t_date) = ?
GROUP BY t.id, t.name
ORDER BY total_out_pence DESC
`

type GetMonthlyReportParams struct {
	UserID int64
	TDate  time.Time
}

type GetMonthlyReportRow struct {
	TagName          sql.NullString
	TotalInPence     sql.NullFloat64
	TotalOutPence    sql.NullFloat64
	TransactionCount int64
}

func (q *Queries) GetMonthlyReport(ctx context.Context, arg GetMonthlyReportParams) ([]GetMonthlyReportRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonthlyReport, arg.UserID, arg.TDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonthlyReportRow
	for rows.Next() {
		var i GetMonthlyReportRow
		if err := rows.Scan(
			&i.TagName,
			&i.TotalInPence,
			&i.TotalOutPence,
			&i.TransactionCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyTotals = `-- name: GetMonthlyTotals :one
SELECT 
    SUM(CASE WHEN amount_pence > 0 THEN amount_pence ELSE 0 END) as total_in_pence,
    SUM(CASE WHEN amount_pence < 0 THEN ABS(amount_pence) ELSE 0 END) as total_out_pence,
    COUNT(*) as transaction_count
FROM transactions
WHERE user_id = ? 
  AND deleted_at IS NULL
  AND strftime('%Y-%m', t_date) = ?
`

type GetMonthlyTotalsParams struct {
	UserID int64
	TDate  time.Time
}

type GetMonthlyTotalsRow struct {
	TotalInPence     sql.NullFloat64
	TotalOutPence    sql.NullFloat64
	TransactionCount int64
}

func (q *Queries) GetMonthlyTotals(ctx context.Context, arg GetMonthlyTotalsParams) (GetMonthlyTotalsRow, error) {
	row := q.db.QueryRowContext(ctx, getMonthlyTotals, arg.UserID, arg.TDate)
	var i GetMonthlyTotalsRow
	err := row.Scan(&i.TotalInPence, &i.TotalOutPence, &i.TransactionCount)
	return i, err
}

const getRecurringByID = `-- name: GetRecurringByID :one
SELECT id, user_id, amount_pence, description, frequency, interval_n, first_due_date, next_due_date, end_date, active, created_at FROM recurring
WHERE id = ?
`

func (q *Queries) GetRecurringByID(ctx context.Context, id int64) (Recurring, error) {
	row := q.db.QueryRowContext(ctx, getRecurringByID, id)
	var i Recurring
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AmountPence,
		&i.Description,
		&i.Frequency,
		&i.IntervalN,
		&i.FirstDueDate,
		&i.NextDueDate,
		&i.EndDate,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const getRecurringByTag = `-- name: GetRecurringByTag :many
SELECT r.id, r.user_id, r.amount_pence, r.description, r.frequency, r.interval_n, r.first_due_date, r.next_due_date, r.end_date, r.active, r.created_at FROM recurring r
JOIN recurring_tags rt ON r.id = rt.recurring_id
WHERE rt.tag_id = ?
ORDER BY r.next_due_date ASC
`

func (q *Queries) GetRecurringByTag(ctx context.Context, tagID int64) ([]Recurring, error) {
	rows, err := q.db.QueryContext(ctx, getRecurringByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recurring
	for rows.Next() {
		var i Recurring
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AmountPence,
			&i.Description,
			&i.Frequency,
			&i.IntervalN,
			&i.FirstDueDate,
			&i.NextDueDate,
			&i.EndDate,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecurringDueOnDate = `-- name: GetRecurringDueOnDate :many
SELECT id, user_id, amount_pence, description, frequency, interval_n, first_due_date, next_due_date, end_date, active, created_at FROM recurring
WHERE active = 1 AND next_due_date <= ?
ORDER BY next_due_date ASC
`

func (q *Queries) GetRecurringDueOnDate(ctx context.Context, nextDueDate time.Time) ([]Recurring, error) {
	rows, err := q.db.QueryContext(ctx, getRecurringDueOnDate, nextDueDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recurring
	for rows.Next() {
		var i Recurring
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AmountPence,
			&i.Description,
			&i.Frequency,
			&i.IntervalN,
			&i.FirstDueDate,
			&i.NextDueDate,
			&i.EndDate,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecurringTags = `-- name: GetRecurringTags :many
SELECT t.id, t.name FROM tags t
JOIN recurring_tags rt ON t.id = rt.tag_id
WHERE rt.recurring_id = ?
ORDER BY t.name
`

func (q *Queries) GetRecurringTags(ctx context.Context, recurringID int64) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getRecurringTags, recurringID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSetting = `-- name: GetSetting :one
SELECT "key", value FROM settings
WHERE key = ?
`

func (q *Queries) GetSetting(ctx context.Context, key string) (Setting, error) {
	row := q.db.QueryRowContext(ctx, getSetting, key)
	var i Setting
	err := row.Scan(&i.Key, &i.Value)
	return i, err
}

const getTagByID = `-- name: GetTagByID :one
SELECT id, name FROM tags
WHERE id = ?
`

func (q *Queries) GetTagByID(ctx context.Context, id int64) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagByID, id)
	var i Tag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getTagByName = `-- name: GetTagByName :one
SELECT id, name FROM tags
WHERE name = ?
`

func (q *Queries) GetTagByName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRowContext(ctx, getTagByName, name)
	var i Tag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, user_id, amount_pence, t_date, note, created_at, source_recurring, deleted_at FROM transactions
WHERE id = ? AND deleted_at IS NULL
`

func (q *Queries) GetTransactionByID(ctx context.Context, id int64) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AmountPence,
		&i.TDate,
		&i.Note,
		&i.CreatedAt,
		&i.SourceRecurring,
		&i.DeletedAt,
	)
	return i, err
}

const getTransactionTags = `-- name: GetTransactionTags :many
SELECT t.id, t.name FROM tags t
JOIN transaction_tags tt ON t.id = tt.tag_id
WHERE tt.transaction_id = ?
ORDER BY t.name
`

func (q *Queries) GetTransactionTags(ctx context.Context, transactionID int64) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionTags, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByRecurringID = `-- name: GetTransactionsByRecurringID :many
SELECT id, user_id, amount_pence, t_date, note, created_at, source_recurring, deleted_at FROM transactions
WHERE source_recurring = ? AND deleted_at IS NULL
ORDER BY t_date DESC
`

func (q *Queries) GetTransactionsByRecurringID(ctx context.Context, sourceRecurring sql.NullInt64) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByRecurringID, sourceRecurring)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AmountPence,
			&i.TDate,
			&i.Note,
			&i.CreatedAt,
			&i.SourceRecurring,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByTag = `-- name: GetTransactionsByTag :many
SELECT tx.id, tx.user_id, tx.amount_pence, tx.t_date, tx.note, tx.created_at, tx.source_recurring, tx.deleted_at FROM transactions tx
JOIN transaction_tags tt ON tx.id = tt.transaction_id
WHERE tt.tag_id = ? AND tx.deleted_at IS NULL
ORDER BY tx.t_date DESC
`

func (q *Queries) GetTransactionsByTag(ctx context.Context, tagID int64) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AmountPence,
			&i.TDate,
			&i.Note,
			&i.CreatedAt,
			&i.SourceRecurring,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, pw_hash, created_at FROM users
WHERE email = ?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PwHash,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, pw_hash, created_at FROM users
WHERE id = ?
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PwHash,
		&i.CreatedAt,
	)
	return i, err
}

const hardDeleteTransaction = `-- name: HardDeleteTransaction :exec
DELETE FROM transactions
WHERE id = ?
`

func (q *Queries) HardDeleteTransaction(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, hardDeleteTransaction, id)
	return err
}

const listActiveRecurring = `-- name: ListActiveRecurring :many
SELECT id, user_id, amount_pence, description, frequency, interval_n, first_due_date, next_due_date, end_date, active, created_at FROM recurring
WHERE user_id = ? AND active = 1
ORDER BY next_due_date ASC
`

func (q *Queries) ListActiveRecurring(ctx context.Context, userID int64) ([]Recurring, error) {
	rows, err := q.db.QueryContext(ctx, listActiveRecurring, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recurring
	for rows.Next() {
		var i Recurring
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AmountPence,
			&i.Description,
			&i.Frequency,
			&i.IntervalN,
			&i.FirstDueDate,
			&i.NextDueDate,
			&i.EndDate,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecurring = `-- name: ListRecurring :many
SELECT id, user_id, amount_pence, description, frequency, interval_n, first_due_date, next_due_date, end_date, active, created_at FROM recurring
WHERE user_id = ?
ORDER BY next_due_date ASC
`

func (q *Queries) ListRecurring(ctx context.Context, userID int64) ([]Recurring, error) {
	rows, err := q.db.QueryContext(ctx, listRecurring, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recurring
	for rows.Next() {
		var i Recurring
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AmountPence,
			&i.Description,
			&i.Frequency,
			&i.IntervalN,
			&i.FirstDueDate,
			&i.NextDueDate,
			&i.EndDate,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSettings = `-- name: ListSettings :many
SELECT "key", value FROM settings
ORDER BY key
`

func (q *Queries) ListSettings(ctx context.Context) ([]Setting, error) {
	rows, err := q.db.QueryContext(ctx, listSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Setting
	for rows.Next() {
		var i Setting
		if err := rows.Scan(&i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTags = `-- name: ListTags :many
SELECT id, name FROM tags
ORDER BY name
`

func (q *Queries) ListTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, listTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, user_id, amount_pence, t_date, note, created_at, source_recurring, deleted_at FROM transactions
WHERE user_id = ? AND deleted_at IS NULL
  AND (t_date >= ? OR ? IS NULL)
  AND (t_date <= ? OR ? IS NULL)
ORDER BY t_date DESC, created_at DESC
`

type ListTransactionsParams struct {
	UserID  int64
	TDate   time.Time
	Column3 interface{}
	TDate_2 time.Time
	Column5 interface{}
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactions,
		arg.UserID,
		arg.TDate,
		arg.Column3,
		arg.TDate_2,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AmountPence,
			&i.TDate,
			&i.Note,
			&i.CreatedAt,
			&i.SourceRecurring,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByDateRange = `-- name: ListTransactionsByDateRange :many
SELECT id, user_id, amount_pence, t_date, note, created_at, source_recurring, deleted_at FROM transactions
WHERE user_id = ? AND deleted_at IS NULL
  AND t_date BETWEEN ? AND ?
ORDER BY t_date DESC, created_at DESC
`

func (q *Queries) ListTransactionsByDateRange(ctx context.Context, userID int64) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsByDateRange, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AmountPence,
			&i.TDate,
			&i.Note,
			&i.CreatedAt,
			&i.SourceRecurring,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, pw_hash, created_at FROM users
ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PwHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const purgeSoftDeletedTransactions = `-- name: PurgeSoftDeletedTransactions :exec
DELETE FROM transactions
WHERE deleted_at IS NOT NULL AND deleted_at < ?
`

func (q *Queries) PurgeSoftDeletedTransactions(ctx context.Context, deletedAt sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, purgeSoftDeletedTransactions, deletedAt)
	return err
}

const softDeleteTransaction = `-- name: SoftDeleteTransaction :exec
UPDATE transactions
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = ? AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteTransaction(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, softDeleteTransaction, id)
	return err
}

const toggleRecurringActive = `-- name: ToggleRecurringActive :exec
UPDATE recurring
SET active = CASE WHEN active = 1 THEN 0 ELSE 1 END
WHERE id = ?
`

func (q *Queries) ToggleRecurringActive(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, toggleRecurringActive, id)
	return err
}

const updateRecurring = `-- name: UpdateRecurring :one
UPDATE recurring
SET amount_pence = ?, description = ?, frequency = ?, interval_n = ?, 
    first_due_date = ?, next_due_date = ?, end_date = ?, active = ?
WHERE id = ?
RETURNING id, user_id, amount_pence, description, frequency, interval_n, first_due_date, next_due_date, end_date, active, created_at
`

type UpdateRecurringParams struct {
	AmountPence  int64
	Description  sql.NullString
	Frequency    string
	IntervalN    int64
	FirstDueDate time.Time
	NextDueDate  time.Time
	EndDate      sql.NullTime
	Active       bool
	ID           int64
}

func (q *Queries) UpdateRecurring(ctx context.Context, arg UpdateRecurringParams) (Recurring, error) {
	row := q.db.QueryRowContext(ctx, updateRecurring,
		arg.AmountPence,
		arg.Description,
		arg.Frequency,
		arg.IntervalN,
		arg.FirstDueDate,
		arg.NextDueDate,
		arg.EndDate,
		arg.Active,
		arg.ID,
	)
	var i Recurring
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AmountPence,
		&i.Description,
		&i.Frequency,
		&i.IntervalN,
		&i.FirstDueDate,
		&i.NextDueDate,
		&i.EndDate,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const updateRecurringNextDue = `-- name: UpdateRecurringNextDue :exec
UPDATE recurring
SET next_due_date = ?
WHERE id = ?
`

type UpdateRecurringNextDueParams struct {
	NextDueDate time.Time
	ID          int64
}

func (q *Queries) UpdateRecurringNextDue(ctx context.Context, arg UpdateRecurringNextDueParams) error {
	_, err := q.db.ExecContext(ctx, updateRecurringNextDue, arg.NextDueDate, arg.ID)
	return err
}

const updateSetting = `-- name: UpdateSetting :one
UPDATE settings
SET value = ?
WHERE key = ?
RETURNING "key", value
`

type UpdateSettingParams struct {
	Value string
	Key   string
}

func (q *Queries) UpdateSetting(ctx context.Context, arg UpdateSettingParams) (Setting, error) {
	row := q.db.QueryRowContext(ctx, updateSetting, arg.Value, arg.Key)
	var i Setting
	err := row.Scan(&i.Key, &i.Value)
	return i, err
}

const updateTag = `-- name: UpdateTag :one
UPDATE tags
SET name = ?
WHERE id = ?
RETURNING id, name
`

type UpdateTagParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, updateTag, arg.Name, arg.ID)
	var i Tag
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const updateTransaction = `-- name: UpdateTransaction :one
UPDATE transactions
SET amount_pence = ?, t_date = ?, note = ?
WHERE id = ? AND deleted_at IS NULL
RETURNING id, user_id, amount_pence, t_date, note, created_at, source_recurring, deleted_at
`

type UpdateTransactionParams struct {
	AmountPence int64
	TDate       time.Time
	Note        sql.NullString
	ID          int64
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, updateTransaction,
		arg.AmountPence,
		arg.TDate,
		arg.Note,
		arg.ID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AmountPence,
		&i.TDate,
		&i.Note,
		&i.CreatedAt,
		&i.SourceRecurring,
		&i.DeletedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET email = ?, pw_hash = ?
WHERE id = ?
RETURNING id, email, pw_hash, created_at
`

type UpdateUserParams struct {
	Email  string
	PwHash string
	ID     int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser, arg.Email, arg.PwHash, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PwHash,
		&i.CreatedAt,
	)
	return i, err
}
